"""
Story Creator â€” creates Jira Story issues from approved decomposition.

Used via CLI: python3 execute.py --create-stories PROJ-123

Workflow:
1. Check that [REVIEW] task is marked Done
2. Re-extract stories from Technical Decomposition comment
3. Create Jira Story issues linked to parent Feature
"""

import re
import logging
from typing import Optional

from ..mcp.client import MCPClientManager
from ..models.decomposition import DecomposedStory

logger = logging.getLogger(__name__)


def check_review_approved(mcp: MCPClientManager, issue_key: str) -> tuple[bool, Optional[str]]:
    """
    Check if the [REVIEW] task for this feature is Done.

    Searches comments for the review task key, then checks its status.

    Args:
        mcp: MCP client manager
        issue_key: Feature issue key

    Returns:
        Tuple of (is_approved, review_task_key)
    """
    # Strategy: search for linked review tasks via JQL
    project_key = issue_key.split("-")[0]
    jql = (
        f'project = "{project_key}" AND summary ~ "[REVIEW] {issue_key}" '
        f'AND issuetype = Story'
    )

    try:
        result = mcp.jira_search_issues(jql, max_results=5)
    except Exception as e:
        logger.error(f"Failed to search for review task: {e}")
        return False, None

    if not result:
        logger.warning(f"No review task found for {issue_key}")
        return False, None

    # Parse the search result to find review task key and status
    # Result format from MCP: lines like "- **KEY-123** Summary (Status: Done, Type: Story)"
    review_key = None
    is_done = False

    for line in result.splitlines():
        key_match = re.search(r"\*\*([A-Z]+-\d+)\*\*", line)
        if key_match:
            candidate_key = key_match.group(1)
            # Verify it's a review task
            if f"[REVIEW] {issue_key}" in line or "[REVIEW]" in line:
                review_key = candidate_key
                # Check status
                status_match = re.search(r"Status:\s*(\w+)", line, re.IGNORECASE)
                if status_match and status_match.group(1).lower() == "done":
                    is_done = True
                break

    if not review_key:
        # Fallback: get issue details directly and check status
        # Try to find review key from comments
        try:
            comments = mcp.jira_get_comments(issue_key)
            for line in comments.splitlines():
                key_match = re.search(r"review task:\s*([A-Z]+-\d+)", line, re.IGNORECASE)
                if key_match:
                    review_key = key_match.group(1)
                    break
        except Exception:
            pass

    if review_key and not is_done:
        # Fetch the review task to check its actual status
        try:
            issue_details = mcp.jira_get_issue(review_key)
            if "Status: Done" in issue_details or "status: Done" in issue_details.lower():
                is_done = True
        except Exception as e:
            logger.error(f"Failed to check review task status: {e}")

    if not review_key:
        logger.warning(f"Could not find [REVIEW] task for {issue_key}")
        return False, None

    return is_done, review_key


def extract_stories_from_comment(mcp: MCPClientManager, issue_key: str) -> list[DecomposedStory]:
    """
    Extract stories from the Technical Decomposition comment on the feature.

    Parses the markdown table and story details sections from Jira comments.

    Args:
        mcp: MCP client manager
        issue_key: Feature issue key

    Returns:
        List of DecomposedStory objects (empty if not found)
    """
    try:
        comments = mcp.jira_get_comments(issue_key)
    except Exception as e:
        logger.error(f"Failed to get comments for {issue_key}: {e}")
        return []

    # Find the Technical Decomposition comment
    decomposition_text = None
    # Split comments by comment boundaries (author/date headers)
    # The decomposition comment starts with "## Technical Decomposition"
    comment_blocks = re.split(r"---\n\n\*\*", comments)

    for block in comment_blocks:
        if "## Technical Decomposition" in block:
            # Extract from ## Technical Decomposition to end of this comment
            start = block.index("## Technical Decomposition")
            decomposition_text = block[start:]
            break

    # Fallback: search the whole comments text
    if not decomposition_text:
        match = re.search(
            r"## Technical Decomposition.*?(?=---\n\*Generated by AI Executor)",
            comments,
            re.DOTALL,
        )
        if match:
            decomposition_text = match.group(0)

    if not decomposition_text:
        logger.warning(f"No Technical Decomposition comment found on {issue_key}")
        return []

    # Parse story details sections
    # Format: #### [LAYER] Title followed by Files and Acceptance
    stories = []
    story_pattern = re.compile(
        r"####\s*\[(\w+)\]\s*(.+?)(?=####|\Z)",
        re.DOTALL,
    )

    order = 0
    for match in story_pattern.finditer(decomposition_text):
        order += 1
        layer = match.group(1).strip()
        content = match.group(2).strip()

        # Extract title from first line
        title_line = content.split("\n")[0].strip()

        # Extract confidence
        confidence = 0.0
        conf_match = re.search(r"\*\*Confidence:\*\*\s*(\d+)%", content)
        if conf_match:
            confidence = int(conf_match.group(1)) / 100.0

        # Extract files
        files = []
        files_section = re.search(
            r"\*\*Files to modify:\*\*\s*\n((?:\s*-\s*.+\n?)+)", content
        )
        if files_section:
            for file_line in files_section.group(1).splitlines():
                file_match = re.search(r"-\s*`?([^`\n]+)`?", file_line)
                if file_match:
                    files.append(file_match.group(1).strip())

        # Extract acceptance criteria
        acceptance = ""
        acc_match = re.search(
            r"\*\*Acceptance Criteria:\*\*\s*\n?(.*?)(?=\*\*|\Z)", content, re.DOTALL
        )
        if acc_match:
            acceptance = acc_match.group(1).strip()

        # Build description from remaining content
        description = content

        story = DecomposedStory(
            layer=layer,
            title=title_line,
            description=description,
            acceptance=acceptance,
            files=files,
            order=order,
            confidence=confidence,
        )
        stories.append(story)

    logger.info(f"Extracted {len(stories)} stories from comment on {issue_key}")
    return stories


def build_story_description(story: DecomposedStory) -> str:
    """
    Build Jira Story description from DecomposedStory.

    Args:
        story: DecomposedStory to format

    Returns:
        Markdown description for Jira
    """
    lines = [
        f"## {story.title}",
        "",
        story.description,
        "",
    ]
    if story.files:
        lines.append("### Files")
        for f in story.files:
            lines.append(f"- `{f}`")
        lines.append("")
    if story.acceptance:
        lines.append("### Acceptance Criteria")
        lines.append(story.acceptance)
        lines.append("")
    if story.confidence > 0:
        lines.append(f"**Confidence:** {story.confidence:.0%}")
        if story.confidence_flags:
            for flag in story.confidence_flags:
                lines.append(f"- {flag}")
        lines.append("")

    return "\n".join(lines)


def create_jira_stories(
    mcp: MCPClientManager,
    parent_key: str,
    project_key: str,
    stories: list[DecomposedStory],
    config: dict,
) -> list[tuple[DecomposedStory, str]]:
    """
    Create Jira Story issues and link to parent Feature.

    For each story:
    1. Create Story issue with "[LAYER] title" summary
    2. Link as child of parent Feature

    Args:
        mcp: MCP client manager
        parent_key: Parent Feature key
        project_key: Jira project key
        stories: List of DecomposedStory objects
        config: SDLC config dict

    Returns:
        List of (story, created_issue_key) tuples
    """
    parent_link_type = config.get("jira", {}).get("parent_link_type", "Parent")
    created: list[tuple[DecomposedStory, str]] = []

    for story in stories:
        summary = f"[{story.layer}] {story.title}"
        # Truncate summary to Jira limit (255 chars)
        if len(summary) > 255:
            summary = summary[:252] + "..."

        description = build_story_description(story)

        try:
            result = mcp.jira_create_issue(
                project_key=project_key,
                issue_type="Story",
                summary=summary,
                description=description,
            )

            # Parse key from result
            key_match = re.search(r"([A-Z]+-\d+)", result)
            if not key_match:
                logger.error(f"Could not parse issue key from: {result}")
                continue

            story_key = key_match.group(1)
            logger.info(f"Created story: {story_key} - {summary}")

            # Link as child of parent Feature
            try:
                mcp.jira_link_issues(
                    from_key=parent_key,
                    to_key=story_key,
                    link_type=parent_link_type,
                )
                logger.info(f"Linked {story_key} as child of {parent_key}")
            except Exception as e:
                logger.warning(f"Failed to link {story_key} to {parent_key}: {e}")

            created.append((story, story_key))

        except Exception as e:
            logger.error(f"Failed to create story '{summary}': {e}")

    return created


def create_dependency_links(
    mcp: MCPClientManager,
    created_stories: list[tuple[DecomposedStory, str]],
) -> int:
    """
    Create blocking links between dependent stories.

    For each story that has depends_on, creates a "Blocks" link
    from the dependency to the dependent story.

    Args:
        mcp: MCP client manager
        created_stories: List of (story, jira_key) tuples from create_jira_stories

    Returns:
        Number of links created
    """
    # Build order -> key mapping
    order_to_key = {story.order: key for story, key in created_stories}

    links_created = 0
    for story, story_key in created_stories:
        for dep_order in story.depends_on:
            dep_key = order_to_key.get(dep_order)
            if not dep_key:
                logger.warning(
                    f"Cannot create dependency link: Step {dep_order} not found "
                    f"(required by {story_key})"
                )
                continue

            try:
                mcp.jira_link_issues(
                    from_key=dep_key,
                    to_key=story_key,
                    link_type="Blocks",
                )
                logger.info(f"Created dependency link: {dep_key} blocks {story_key}")
                links_created += 1
            except Exception as e:
                logger.warning(f"Failed to create dependency link {dep_key} -> {story_key}: {e}")

    return links_created
